#!/usr/bin/env python3

# libraries
import os
import sys
import re
import html
import subprocess
import pycrfsuite
from tempfile import TemporaryDirectory, NamedTemporaryFile
from pathlib import Path
from docopt import docopt
from lxml import etree

from .config import PKG_NAME, VERSION
from .exceptions import AlreadyTaggedError
from .cli_utils import set_logger
from .structures import Document

# help text
MOD_NAME = "{}.mathtagger".format(PKG_NAME)
HELP = """
Embed inline/independent math-tags to XHTML files
which are generated by 'pdfanalyzer'.

Usage:
    {m} tag [options] XHTML...
    {m} learn [options] XHTML...
    {m} -h | --help
    {m} -V | --version

Options:
    -h, --help             Show this screen and exit.
    -F, --force            Ignore embedded math tags.
    -l FILE, --log=FILE    Output messages to FILE.
    -m FILE, --model=FILE  Use FILE as model file.
    -o DIR, --out=DIR      Output files to DIR.
    -q, --quiet            Show less messages.
    -v, --verbose          Show more messages.
    -V, --version          Show version.

""".format(m=MOD_NAME)

# use logger
from logging import getLogger
logger = getLogger('postprocess')


class MathTagger:
    ns = {'x': 'http://www.w3.org/1999/xhtml'}

    def __init__(self, modelfile, force=False):
        """The constructor

        Args:
            modelfile (string): The modelfile of the crfsuite

        """

        # Instance variables
        self.modelfile = modelfile
        self.force = force
        self.tagger = None
        self.doc = None
        self.docid = None
        self.fontspecs = {}
        self.mathtags = None

        logger.info('MathTagger initialized.')

    def open(self, doc):
        """Open a XHTML file.

        Args:
            doc (Document): The input document.
        """
        self.doc = doc
        self.docid = self.__get_docid()
        self.fontspecs = self.__get_fontspecs()
        self.mathtags = None
        self.__get_equation_and_main_fonts()
        self.__get_feature_list()
        logger.info('Now docid = {}'.format(self.docid))

    def tag(self, force=None):
        """Embed 'data-math' tags using CRFSuite.

        Args:
            force (bool): If this parameter is set to false,
                          processed files raise an exception.
        """
        if self.docid is None:
            logger.error('The docid is empty.')
            return False

        if force is None:
            force = self.force

        if not force:
            if len(
                    self.doc.tree.xpath(
                        'x:body/x:div/x:div/x:p/x:span[@data-math]',
                        namespaces=MathTagger.ns)) > 0:
                raise AlreadyTaggedError

        # Clear embedded 'data-math' attributes
        for word in self.doc.tree.xpath(
                'x:body/x:div/x:div/x:p/x:span[@data-math]',
                namespaces=MathTagger.ns):
            del word.attrib['data-math']

        # Set tagger
        if self.tagger is None:
            if os.path.isfile(self.modelfile) is not True:
                logger.error(
                    'The modelfile {} is not exist or readable'.format(
                        self.modelfile))
                return False

            self.tagger = pycrfsuite.Tagger()
            self.tagger.open(self.modelfile)
            logger.info("A tagger instance is created from '{}'".format(
                self.modelfile))

        # Create data list
        xseq = []
        wids = []
        for paragraph in self.feature_list:
            p_id = paragraph["id"]
            for word in paragraph["words"]:
                w_id, spell, start, end, features = word
                f = re.split(r'\s+', features)
                f.remove('')
                xseq.append(f)
                wids.append(w_id)

        # Execute `crfsuite` in tag mode
        yseq = self.tagger.tag(xseq)

        total = 0
        for i in range(len(wids)):
            if yseq[i] == 'O':
                continue
            for word_element in self.doc.tree.xpath(
                    '//x:span[@id="{}"]'.format(wids[i]),
                    namespaces=MathTagger.ns):
                word_element.attrib['data-math'] = yseq[i]
                total += 1

        logger.info("Embed {} data-math tags.".format(total))
        return total

    def outputXhtml(self, filename=None):
        """Write xhtml to the file.

        If the filename is not specified, output to the stdout.
        """
        if filename is None:
            logger.info("Output xhtml to stdout")
            sys.stdout.buffer.write(etree.tostring(self.doc.tree))
        else:
            logger.info("Output xhtml to '{}'".format(filename))
            with open(filename, 'w+b') as fp:
                fp.write(etree.tostring(self.doc.tree))

    @staticmethod
    def learn(xhtml_files, modelfile):
        """Learn model from the XHTML files.
        """
        mathtagger = MathTagger(modelfile, False)
        xseq = []
        yseq = []

        for xhtml_file in xhtml_files:
            logger.info("Reading '{}'".format(xhtml_file))
            fn = Path(xhtml_file)

            doc = Document(str(fn))
            mathtagger.open(doc)
            for paragraph in mathtagger.__get_feature_list():
                for word in paragraph["words"]:
                    w_id, spell, start, end, features = word
                    mathtag = mathtagger.__get_mathtag(w_id)
                    f = re.split(r'\s+', features)
                    f.remove('')
                    xseq.append(f)
                    yseq.append(mathtag)

        # Execute train
        trainer = pycrfsuite.Trainer()
        trainer.append(xseq, yseq)
        trainer.train(modelfile)

        return

    @staticmethod
    def __get_fontkey_from_fontspec(fontspec):
        """Generate fontname from fontspec
        """
        fontkey = fontspec['name'] + '-' + fontspec['size'][0:-2]
        return fontkey

    @staticmethod
    def __may_formula(string):
        """Check whether the string may be a formula or not.
        If it contains parentheses, Greek letters, mathematical symbols, it is judged that there is a possibility.

        The codes of mathematical symbols are from U+2200 to U+22ff.

        Args:
            string (string): The input string which will be judged.
        """
        if re.search(r'[<->\(\)\{\}\[\]Α-Ωα-ω]', string):
            return True
        if re.search(r'[\u2200-\u22ff]', string):
            return True
        return False

    def __get_docid(self):
        """Get docid from the document element.
        """
        docid = self.doc.tree.xpath(
            'x:head/x:meta/@docid', namespaces=MathTagger.ns)
        if docid is None:
            logger.error('This docid is not defined.')
            return False
        else:
            self.docid = docid[0]

        return self.docid

    def __get_fontspecs(self):
        """Get font information from the document elements.
        """
        self.fontspecs = {}
        for font in self.doc.tree.xpath(
                'x:head/x:ftypes/x:fontspec', namespaces=MathTagger.ns):
            attrib = font.attrib
            self.fontspecs[attrib['id']] = attrib

        return self.fontspecs

    def __get_mathtag(self, wid):
        """Get 'data-math' attribute value in the element
        whose id is equal to 'wid'.
        """
        if self.mathtags is None:
            self.mathtags = {}
            for word in self.doc.tree.xpath(
                    'x:body/x:div/x:div/x:p/x:span', namespaces=MathTagger.ns):

                if 'id' not in word.attrib or 'data-math' not in word.attrib:
                    continue

                self.mathtags[word.attrib['id']] = word.attrib['data-math']

        if wid in self.mathtags:
            return self.mathtags[wid]

        return 'O'

    def __get_equation_and_main_fonts(self):
        """Count the frequency of fonts that appear in sentences.

        The most frequent font is the 'main font' (return value).

        The fonts and words appears in 'Equation' blocks are
        stored in instance variables.

        - self.equation_fonttypes (set):
            Fonttypes in equation blocks.
        - self.equation_spells (set):
            Word notations in equation blocks.
        - self.equation_font_spells (dictionary):
            Fonttypes with notations in equation blocks.
        """
        self.feature_list = []
        self.text_list = []
        # fontspecs = self.get_fontspecs()

        # Count font frequency
        font_freqs = {}
        self.equation_fonttypes = set()
        self.equation_spells = set()
        self.equation_font_spells = {}
        for box in self.doc.tree.xpath(
                'x:body/x:div/x:div', namespaces=MathTagger.ns):
            for word in box.xpath('x:p/x:span', namespaces=MathTagger.ns):
                if 'data-ftype' not in word.attrib:
                    continue

                ftype = word.attrib['data-ftype']
                w = word.text

                if 'data-name' in box.attrib \
                        and box.attrib['data-name'] == 'Equation':
                    self.equation_fonttypes.add(ftype)
                    self.equation_spells.add(w)
                    if ftype not in self.equation_font_spells:
                        self.equation_font_spells[ftype] = set()
                    self.equation_font_spells[ftype].add(w)

                if ftype not in font_freqs:
                    font_freqs[ftype] = 0
                font_freqs[ftype] += 1

        maxfreq = -1
        self.mainfont = None
        for ftype, freq in font_freqs.items():
            if freq > maxfreq:
                self.mainfont = ftype
                maxfreq = freq

        return self.mainfont

    def __get_feature_list(self):
        for box in self.doc.tree.xpath(
                'x:body/x:div/x:div', namespaces=MathTagger.ns):
            boxtype = box.attrib['data-name']
            if boxtype.lower() not in ('title', 'abstract', 'body', 'listitem',
                                       'caption'):
                continue

            for paragraph in box.xpath('x:p', namespaces=MathTagger.ns):
                may_math_paragraph = False

                p_id = paragraph.attrib['id']
                p_text = ''
                p_cursor = 0
                position_map = {}
                features = []
                text_output_content = ''
                is_url = False

                # Get word information
                for word in paragraph.xpath(
                        'x:span', namespaces=MathTagger.ns):
                    if 'data-ftype' not in word.attrib:
                        continue
                    if word.text is None:
                        continue
                    ftype = word.attrib['data-ftype']
                    w_id = word.attrib['id']

                    # Get word notations and positions
                    spell = html.unescape(word.text)
                    length = len(spell)
                    if len(p_text) > 0:
                        p_text += ' '
                        p_cursor += 1
                    p_text += spell
                    position_map[w_id] = (p_cursor, p_cursor + length)
                    p_cursor += length

                    # Check whether the word is in a URL string or not
                    if is_url:
                        if word.attrib['data-space'] == 'space':
                            is_url = False
                    elif spell.lower() in ('http', 'https'):
                        is_url = True

                    # Check whether the word's font and notation are
                    # appered in Equation blocks
                    fontkey = self.__get_fontkey_from_fontspec(
                        self.fontspecs[ftype])
                    feature = {
                        "id": w_id,
                        "w": spell,
                        "f": fontkey,
                        "len": length
                    }
                    fontspell = fontkey + '_' + spell
                    feature[
                        'equ_font'] = 't' if ftype in self.equation_fonttypes else 'f'
                    feature[
                        'equ_spell'] = 't' if spell in self.equation_spells else 'f'
                    feature[
                        'equ_fontspell'] = 't' if ftype in self.equation_font_spells and spell in self.equation_font_spells[
                            ftype] else 'f'

                    # Other features
                    feature['alpha'] = 't' if re.search(
                        r'^[A-Za-z]+$', spell) is not None else 'f'
                    feature['greek'] = 't' if re.search(
                        r'[Α-Ωα-ω]', spell) is not None else 'f'
                    feature['algebra'] = 't' if re.search(
                        r'[<->\u2200-\u22ff]', spell) is not None else 'f'
                    feature['singlechar'] = 't' if len(spell) == 1 else 'f'
                    feature[
                        'mainfont'] = 't' if ftype == self.mainfont else 'f'
                    feature['box-type'] = boxtype
                    feature['url'] = 't' if is_url is not False else 'f'

                    features.append(feature)

                    # May this paragraph contain formulae?
                    if re.search(r'CMMI', fontkey) \
                            or feature['equ_font'] \
                            or self.__may_formula(spell):
                        may_math_paragraph = True

                # Output features for each paragraph
                if boxtype == 'Equation':
                    is_equation = 'E'
                else:
                    is_equation = 'N'

                paragraph_features = []
                for wi in range(len(features)):
                    feature = features[wi]
                    w_id = feature['id']
                    f = ''
                    for i in [-3, -2, -1, 0, 1, 2, 3]:
                        if wi + i < 0 or wi + i >= len(features):
                            continue
                        feature2 = features[wi + i]
                        for k, v in feature2.items():
                            if k not in ("id", ):
                                f += "{0:s}[{1:d}]={2} ".format(k, i, v)

                    paragraph_features.append([
                        w_id, feature['w'], position_map[w_id][0],
                        position_map[w_id][1], f
                    ])

                self.feature_list.append({
                    "id": p_id,
                    "words": paragraph_features
                })
                self.text_list.append({"id": p_id, "text": p_text})

        return self.feature_list


def mathtagger_cui():
    """The test function
    """
    # parse options and arguments
    args = docopt(HELP, version=VERSION)

    # setup the logger
    log_level = 1  # info (default)
    if args['--quiet']:
        log_level = 0  # warn
    if args['--verbose']:
        log_level = 2  # debug

    log_file = args['--log']  # output messages stderr as default

    set_logger(log_level, log_file)

    # model file
    if args['--model'] is None:
        modelfile = 'postprocess/mathtagger/model/inline_math.model'
    else:
        modelfile = args['--model']

    # the "tag" operation
    if args['tag']:
        force_flag = False
        if args['--force']:
            force_flag = True

        mathtagger = MathTagger(modelfile, force_flag)

        # Embed 'data-math' attributes the XHTML files
        for fn in args['XHTML']:
            fn = Path(fn)

            doc = Document(str(fn))
            mathtagger.open(doc)
            mathtagger.tag(force_flag)

            if args['--out']:
                out_dir = Path(args['--out'])
                out_dir.mkdir(parents=True, exist_ok=True)
                mathtagger.outputXhtml(str(out_dir / fn.name))
            else:
                mathtagger.outputXhtml()

    # the "learn" operation
    elif args['learn']:
        if os.path.isfile(modelfile):
            # Backup file
            import shutil
            import datetime
            date = datetime.datetime.now().date().isoformat()
            shutil.copy(modelfile, modelfile + "." + date)

        # Learn model from the XHTML files
        MathTagger.learn(args['XHTML'], modelfile)


if __name__ == '__main__':
    mathtagger_cui()
